using System.Text;

namespace Fluxcp.LowLevel;
internal sealed class NasmGenerator : IGenerator
{
    private readonly Stream strout;
    private EventWaitHandle waitHandle;
    private StringBuilder currInst;
    private int offset;
    public NasmGenerator(Stream strout_) 
    {
        strout = strout_;

        waitHandle = new ManualResetEvent(true);
        currInst = new StringBuilder();
        // for now no .data section 
        currInst.Append(";Automatically generated by FluxCp open source compiler, feel free to use under the MIT License. \n"+
        "section .text\n" + 
        "global Main\n");
        ExecuteBase();
    }
    // creates a stack frame with initial offset for return type and arguments
    public NasmStackFrame CreateStackFrame(uint retSize, string? labelName, params uint[] argsSize) 
    {
        if (labelName != null) currInst.Append($"\n    {labelName}:");
        currInst.Append(
        "\npush rbp" + 
        "\nmov rbp, rsp" + 
       $"\nsub rsp, {retSize + argsSize.Sum(i => i)}");
        ExecuteBase();
        return new NasmStackFrame(retSize, argsSize);
    }
    // allocates space on stack (substracts local var type size)
    public void AllocSizeForLocal(uint lsize, NasmStackFrame sFrame) 
    {
        currInst.Append($"\nsub rsp, {lsize}");
        ExecuteBase();
        sFrame.Locals.Add(lsize);
    } 
    // removes a current stack frame
    public void RemoveStackFrame() 
    {
        currInst.Append(
        "\nmov rsp, rbp" + 
        "\npop rbp" + 
        "\nret");
        ExecuteBase();
    }
    public void CallLabel(string labelName) 
    {
        currInst.Append($"\ncall {labelName}");
        ExecuteBase();
    }
    // update local variable in current stack frame (offset 0 - return var, 1 - local or argument etc.)
    // offset - 0 for return value, then arguments and then locals
    // data - data to be written
    // insertPos - insert position offset, for example insertPos 1 means that [rsp + 1]
    // insertLen - length of data to be written
    public void UpdateLocal(uint offset, byte[] data, int insertPos, int insertLen, NasmStackFrame sFrame) 
    {
        // nasm uses little endian so we have to reverse data array
        /* for(int i = 0; i < data.Length / 2; i++) 
        {
            byte tmp = data[i];
            data[i] = data[data.Length - i - 1];
            data[data.Length - i - 1] = tmp;
        } */

        uint baseOffset = sFrame.RetSize;

        if (offset > sFrame.ArgsSize.Length) 
        {
            baseOffset += (uint)sFrame.ArgsSize.Sum(i => i);
            for(int i = 0; i < offset - 1 - sFrame.ArgsSize.Length; i++) 
            {
                baseOffset += sFrame.Locals[i];
            }
        }
        else if (offset > 0)
        {
            for(int i = 0; i < offset - 1; i++) 
            {
                baseOffset += sFrame.ArgsSize[i];
            }
        }

        // and now we have to generate several times "mov" instruction
        int bytesWritten = 0;
        int dataLength = data.Length;
        while (bytesWritten < insertLen) 
        {
            string hexData = null!;
            switch(dataLength) 
            {
                case >= 8:
                    hexData = string.Join("", Enumerable.Range(0, 8).Select((i, ind) => 
                        data[bytesWritten + ind].ToString("X2")));
                    bytesWritten += 8;
                    currInst.Append($"\nmov qword [rbp - {baseOffset + bytesWritten}], 0x" + hexData);
                    break;
                case >= 4:
                    hexData = string.Join("", Enumerable.Range(0, 4).Select((i, ind) => 
                        data[bytesWritten + ind].ToString("X2")));
                    bytesWritten += 4;
                    currInst.Append($"\nmov dword [rbp - {baseOffset + bytesWritten}], 0x" + hexData);
                    break;
                case >= 2:
                    hexData = string.Join("", Enumerable.Range(0, 2).Select((i, ind) => 
                        data[bytesWritten + ind].ToString("X2")));
                    bytesWritten += 2;
                    currInst.Append($"\nmov word [rbp - {baseOffset + bytesWritten}], 0x" + hexData);
                    break;
                default:
                    hexData = data[bytesWritten].ToString("X2");
                    bytesWritten++;
                    currInst.Append($"\nmov byte [rbp - {baseOffset + bytesWritten}], 0x" + hexData);
                    break;
            }
            ExecuteBase();
        }
    }
    private void ExecuteBase() 
    {
        waitHandle.WaitOne();
        waitHandle.Reset();
        strout.BeginWrite(Encoding.UTF8.GetBytes(currInst.ToString()), 0, currInst.Length, AsyncCallBack, true);
        offset += currInst.Length;
        currInst.Clear();
    }
    private void AsyncCallBack(IAsyncResult ar) 
    {
        if (ar.AsyncState is bool b && b) 
        {
            waitHandle.Set(); // unblocking handle
        }
    }   
}